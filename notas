cd src/
make all_bin -> make all

cd ../num
/probsemSharedMemSoccerGame


outras cenas:

(R)eferee - inicia o jogo, tem que haver 1 para se iniciar, e é quem termina, 
                    depois de assegurar que todos os jogadores já iniciaram

cada equipa:
4 (P)layers
1 (G)oalies


if players or goalies > total, avisar atrasados e não entram

P G e R - processos independentes
        - comunicam através de semáforos e memória partilhada
        - criados a partir de probSemSharedMemSoccerGame e existem desde aí
        - tempo de chegada = distribuição de prob. uniforme
        - processos devem bloquear para esperar por algum evento

ficheiros a alterar:
        - semSharedMemPlayer.c
        - semSharedMemGoalie.c
        - semSharedMemReferee.c

(F)orming

Estados
    Goalies < 2 **
 A ------------> W      -> SemDown(..., goaliesWaitTeam)
|  \ *                     SemUp(..., playerRegisted)
|>2  \ = 2
L     |-> F <-|
          |   |
           Not|All Team | Team Complete
          |-> |waiting  | SemUp(..., playersWaitTeam)
                        | SemDown(..., playersRegister)
                        
        * and All Team Complete
       ** or Not All Teams 

Avaliação:
    - Relatório denovo ffs
    - valoriza-se deteção de erros, verificação dos valores dos semáforos (semup e semdown)

Notas da aula TP:
saveState(NULL,sh->fSt);
Só cada agente é que pode mudar o seu próprio estado

Podemos testar cada tipo de agente individualmente (make pl, make gl, make)
all_bin -> ficheiros dos profs
all -> versão de teste final, usa o código feito por nós

usar clean.sh (ou ipcs e ipcrm)

Usar o filter.sh para ser mais fácil analisar

Podemos correr os programas mais que 1 vez: ./run 20

Podem ser alterados pelos profesores os tempos dos players, goalies, referees, até para questões de teste

Ideia tirada do Vasco -> Fazer diagrama de estados 

